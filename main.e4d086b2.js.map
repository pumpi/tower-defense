{"version":3,"sources":["js/helpers.js","js/game.settings.js","js/game.mapEntities.js","js/game.map.js","js/game.enemies.js","js/game.mouse.js","js/game.towers.js","js/game.js","js/main.js"],"names":["_sortEntity","listIndex","sort","a","b","y","zIndex","createImage","src","spr","img","Image","sprites","drawSprite","image","spriteInd","x","w","h","ctx","drawImage","drawAnimatedSprite","frameInd","frames","parseInt","playerLifes","towers","laser","costs","color","size","fireRange","damage","from","to","coolDownTime","images","helpers","require","audio","upgrades","cost","mapGrid","enemyMinSize","enemyLevelIncAt","enemyLevels","speed","health","waves","name","template","count","waveFactor","coolDown","level","delay","delayFactor","list","idCounter","init","self","on","update","draw","create","r","entity","id","type","remove","drawCircle","i","drawList","push","waypoints","background","game","canvas","width","height","grid","settings","isValidTowerPlace","me","left","top","right","bottom","length","x1","Math","min","y1","x2","max","y2","r2","intersectRect","mapEntities","distance","gap","beginPath","strokeStyle","lineWidth","moveTo","lineTo","stroke","irlicht","bug","enemiesList","deleted","index","splice","wave","shift","round","random","waypointIndex","waypoint","velocity","enemySettings","maxHealth","direction","frame","enemyType","nextWaypoint","Object","assign","map","oldX","oldY","waypointReached","die","done","enemies","healthPercent","healthBar","fillStyle","fillRect","stat","calculateReward","enemy","life","resetGame","alert","base","clicked","addEventListener","onMove","onClick","mouse","e","offsetX","offsetY","isMouseOver","radius","sqrt","pow","gridPosition","bullet","tower","cooldownTime","barell","Audio","volume","stats","shoots","dmg","kills","cooldownCounter","closestEnemy","upgrade","coins","closeOptions","closestDistance","Number","MAX_SAFE_INTEGER","shoot","play","openOptions","floor","eDistance","dRatio","save","restore","drawTower","optionsModal","document","querySelector","output","classList","onclick","add","getElementById","getContext","setInterval","bind","waveCounter","buyTower","trigger","window","requestAnimationFrame","clearRect","apply","value","undefined","query","innerHTML","r1","fill","arc","PI","nextWave","keys","levelInc","maxTemplate","spawn","ec","setTimeout","eventsList","event","fn","target","matches","preventDefault"],"mappings":"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","file":"main.e4d086b2.js","sourceRoot":"../src","sourcesContent":["import game from './game';\n\nexport default {\n\n    _sortEntity: function (listIndex) {\n        // Die Liste mit den zu zeichnenden Objekten vorsortieren\n        // damit die weiter oben angesetzten Objekte hinter den Vorderen liegen.\n        this[listIndex].sort(function (a, b) {\n            return a.y > b.y || b.zIndex - a.zIndex;\n        });\n    },\n    createImage : function(src, spr = []) {\n        let img = new Image();\n        img.src = src;\n        img.sprites = spr;\n        return img;\n    },\n    drawSprite: function(image, spriteInd, x, y, w, h){\n        // image is the image. Must have an array of sprites\n        // image.sprites = [{x:0,y:0,w:10,h:10},{x:20,y:0,w:30,h:40},....]\n        // where the position and size of each sprite is kept\n        // spriteInd is the index of the sprite\n        // x,y position on sprite center\n        // cw, ch the final container width and height\n        let spr = image.sprites[spriteInd];\n        //game.ctx.setTransform(1,0,0,1,x,y); // set scale and position\n        game.ctx.drawImage(image,spr.x,spr.y,w,h,x - spr.w / 2,y - spr.h / 2,spr.w,spr.h); // render the subimage\n    },\n    drawAnimatedSprite: function(image, spriteInd, frameInd, x, y, w, h){\n        // image is the image. Must have an array of sprites\n        // image.sprites = [{x:0,y:0,w:10,h:10},{x:20,y:0,w:30,h:40},....]\n        // where the position and size of each sprite is kept\n        // spriteInd is the index of the sprite\n        // x,y position on sprite center\n        // cw, ch the final container width and height\n        let spr = image.sprites[spriteInd];\n        //game.ctx.setTransform(1,0,0,1,x,y); // set scale and position\n        game.ctx.drawImage(image,spr.frames[parseInt(frameInd)],spr.y,w,h,x - spr.w / 2,y - spr.h / 2,spr.w,spr.h); // render the subimage\n    }\n}","import helpers from './helpers';\nimport game from './game'\n\nexport default {\n    playerLifes: 10,\t\t// Lebenspunkte des Spielers\n\n    towers: {\n        laser: {\n            costs: 80,\t\t            // Kosten für einen Tower (in Coins)\n            color: '#ffff03',           // Farbe der Türme (ist fix)\n            size: 20,\t\t            // Größe der Türme (fixer Radius)\n            fireRange: 110,\t\t        // Anfängliche Reichweite eines Turms (kann per Upgrade für alle Türme erhöht werden)\n            damage: {from: 3, to: 4},   // Anfänglicher Schaden den ein Turm bewirkt (kann per Upgrade für alle Türme erhöht werden)\n            coolDownTime: 16,\t        // Anfängliche Schussverzögerung eines Turms (kann per Upgrade für alle Türme erhöht werden)\n            images: helpers.createImage(require('/img/tower/laser.png'), [\n                {x: 0, y: 0, w: 80, h: 80},\n                {x: 0, y: 160, w: 80, h: 80},\n                {x: 0, y: 320, w: 80, h: 80},\n                {x: 0, y: 480, w: 80, h: 80},\n                {x: 0, y: 640, w: 80, h: 80},\n                {x: 0, y: 800, w: 80, h: 80}\n            ]),\n            audio: require('/audio/laser.mp3'),\n            upgrades: [\n                {cost: 120, fireRange: 120, damage: {from: 7, to: 11}, color: '#2CE85B'},\n                {cost: 190, fireRange: 130, damage: {from: 14, to: 21}, color: '#2CE8B9'},\n                {cost: 280, fireRange: 140, damage: {from: 23, to: 34}, color: '#2A62DB'}\n            ]\n        }\n\n    },\n\n    mapGrid: 80,\n\n    enemyMinSize: 3,\n    enemyLevelIncAt: 15,\n    enemyLevels: [\n        {speed: 1.5, health: 20, color: 'rgb(250,0,0)'},\n        {speed: 2, health: 35, color: 'rgb(200,0,0)'},\n        {speed: 3, health: 50, color: 'rgb(150,0,0)'},\n        {speed: 4, health: 80, color: 'rgb(100,0,0)'},\n        {speed: 3, health: 100, color: 'rgb(50,0,0)'},\n        {speed: 2, health: 150, color: 'rgb(30,30,30)'},\n        {speed: 2, health: 120, color: 'rgb(15,15,15)'},\n        {speed: 5, health: 160, color: 'rgb(0,0,0)'}, // <== Endgegner\n    ],\n\n    /**\n     * jedes tamplate enhält ein objekt pro spawn welle\n     * jedes objekt beinhaltet folgende Variablen für die konfiguration\n     * @param int count         - Anzahl der zu spawnenden Gegner\n     * @param int waveFactor    - Multiplikator für die zusätzlichen gegner je welle\n     * @param int coolDown      - Abstand der gegner in millisekunden\n     * @param int level         - Level des gegners\n     * @param int delay         - Verzögerung zum nächsten Template nach Vollendung des aktuellen\n     * @param int delayFactor   - Dieser factor bestimmt wieviel des delays in den Abstand für den Spawn der nächsten Welle mit einfließt\n     *                            Beispeil ein Faktor von 0.5 setzt den nächsten Teil der Welle in der Hälfte aller vorherigen Spawns ein\n     */\n    waves: [\n        {\n            name: 'A lot small enemies',\n            template: [\n                {count: 4, waveFactor: 1, coolDown: 800, level: 0, delay: 0, delayFactor: 0.5},\n                {count: 0, waveFactor: 0.4, coolDown: 500, level: 1, delay: 0, delayFactor: 0}\n            ]\n        }\n    ]\n};","import helpers from './helpers';\nimport game from './game';\n\nexport default {\n    list: {},\n    idCounter: 0,\n    init: function () {\n        var self = this;\n        game.on('update', function () {\n            self.update();\n        });\n        game.on('beforeDraw', function () {\n            self.draw();\n        });\n    },\n    create: function (x, y, r, color) {\n        let self = this,\n            id = ++this.idCounter,\n            entity = {\n                id: id,\n                type: 0,\t\t// Entity-Typ zur Unterscheidung der Entities\n                x: x,\t\t\t// X-Position auf dem Canvas\n                y: y,\t\t\t// Y-Position auf dem Canvas\n                r: r,\t\t\t// Radius für die Kollisionserkennung (und auch zum Zeichnen)\n                color: color,\t// Farbe zum zeichnen\n                level: 0,       // Entity Level\n                zIndex: 0,      // Entity zIndex\n                // 30 mal in der Sekunde wird diese Methode aufgerufen.\n                // Hier lassen sich getaktete Abläufe realisieren.\n                update: function () {\n                },\n                remove: function () {\n                    self.remove(this.id);\n                },\n                // Die \"draw\"-Funktion wird so oft in der Sekunde aufgerufen wie es das Betriebssystem vorgibt.\n                // Getaktete Abläufe lassen sich hier also nicht umsetzen - dafür ist die \"Update\"-Methode da.\n                // Hier kann das Canvas bemalt werden. Dazu werden die Eigenschaften x,y,r und color verwendet.\n                draw: function () {\n                    game.drawCircle(this.x, this.y, this.r, this.color, true);\n                },\n            };\n        this.list[entity.id] = entity;\n        return entity;\n    },\n    remove: function (id) {\n        delete this.list[id];\n    },\n    update: function () {\n        // Für jedes mapEntity rufen wir dessen \"update\"-Methode auf\n        //for(let i=0; i<this.list.length; i++) this.list[i].update();\n        for (let i in this.list) this.list[i].update();\n    },\n    draw: function () {\n        // Alle Objekte zur drawList hinzufügen.\n        // Dort werden sie sortiert und deren \"draw()\"-Methode aufgerufen.\n        //for(let i=0; i<this.list.length; i++) game.drawList.push(this.list[i]);\n        for (let i in this.list) game.drawList.push(this.list[i]);\n    },\n};","import helpers from './helpers';\nimport game from './game';\nimport settings from './game.settings';\nimport mapEntities from './game.mapEntities'\n\nexport default {\n    waypoints: [\n        {x: 0, y: 120},\n        {x: 120, y: 120},\n        {x: 120, y: 360},\n        {x: 360, y: 360},\n        {x: 360, y: 200},\n        {x: 520, y: 200},\n        {x: 520, y: 520},\n        {x: 680, y: 520},\n        {x: 680, y: 280},\n        {x: 800, y: 280},\n        {x: 920, y: 280},\n        {x: 920, y: 200},\n        {x: 1200, y: 200},\n    ],\n    images: {\n        background: helpers.createImage(require('/img/background.png'))\n    },\n    init: function () {\n        var self = this;\n        game.on('update', function () {\n            self.update();\n        });\n        game.on('beforeDraw', function () {\n            self.draw();\n        });\n    },\n    update: function () {\n    },\n    draw: function () {\n        // Rahmen und das Canvas herumziehen um die Ausmaße besser zu erkennen\n        game.ctx.drawImage(this.images.background,0,0,game.canvas.width,game.canvas.height);\n\n        // Game Raster\n        this.grid(settings.mapGrid);\n\n        // game.ctx.save();\n        // game.ctx.beginPath();\n        // game.ctx.strokeStyle = 'rgb(170,170,170)';\n        // game.ctx.lineWidth = settings.mapGrid;\n        // game.ctx.moveTo(map.waypoints[0].x, map.waypoints[0].y);\n        // for (let i = 1; i < map.waypoints.length; i++)\n        //     game.ctx.lineTo(map.waypoints[i].x, map.waypoints[i].y);\n        // game.ctx.stroke();\n        //\n        // game.ctx.restore();\n    },\n    isValidTowerPlace: function (x, y) {\n        let me = this;\n\n        // TODO We can buy some types of towers in future\n        let bullet = 'laser'\n\n        let r = {\n            left: x - settings.towers[bullet].size,\n            top: y - settings.towers[bullet].size,\n            right: x + settings.towers[bullet].size,\n            bottom: y + settings.towers[bullet].size,\n        };\n\n        for (let i = 0; i < me.waypoints.length - 1; i++) {\n            let x1 = Math.min(me.waypoints[i + 1].x, me.waypoints[i].x);\n            let y1 = Math.min(me.waypoints[i + 1].y, me.waypoints[i].y);\n\n            let x2 = Math.max(me.waypoints[i + 1].x, me.waypoints[i].x);\n            let y2 = Math.max(me.waypoints[i + 1].y, me.waypoints[i].y);\n\n            let width = (x2 - x1) + 80;\n            let height = (y2 - y1) + 80;\n\n            x1 -= 40;\n            y1 -= 40;\n            x2 = x1 + width;\n            y2 = y1 + height;\n            let r2 = {\n                left: x1,\n                top: y1,\n                right: x2,\n                bottom: y2\n            };\n            if (game.intersectRect(r, r2)) return false;\n        }\n\n        for ( let id in mapEntities.list ) {\n            let entity = mapEntities.list[id];\n            if ( entity.type === 'tower' && game.distance(entity.x, entity.y, x, y) <= settings.towers[bullet].size * 2) {\n                return false;\n            }\n        }\n\n        return true;\n    },\n    grid: function(gap) {\n\n        // Horizontale Linie\n        game.ctx.beginPath();\n        game.ctx.strokeStyle = '#ffffff22';\n        game.ctx.lineWidth = 1;\n        for ( let y = gap; y < game.canvas.height; y += gap ) {\n            game.ctx.moveTo(0, y);\n            game.ctx.lineTo( game.canvas.width, y);\n        }\n\n        // Verticale Linie\n        for ( let x = gap; x < game.canvas.width; x += gap ) {\n            game.ctx.moveTo(x, 0);\n            game.ctx.lineTo( x, game.canvas.height);\n\n        }\n        game.ctx.stroke();\n    }\n};","import helpers from './helpers';\nimport game from './game';\nimport enemies from './game.enemies';\nimport mapEntities from './game.mapEntities';\nimport settings from './game.settings';\nimport map from './game.map';\n\nexport default {\n    images: {\n        irlicht:  helpers.createImage(require('/img/enemy/irlicht.png'), [\n            { x: 0, y: 0, w: 20, h: 20, frames: [0,40,80,120,160,200]},\n            { x: 0, y: 40, w: 20, h: 20, frames: [0,40,80,120,160,200] },\n            { x: 0, y: 80, w: 20, h: 20, frames: [0,40,80,120,160,200] },\n            { x: 0, y: 120, w: 20, h: 20, frames: [0,40,80,120,160,200] }\n        ]),\n        bug:  helpers.createImage(require('/img/enemy/bug.png'), [\n            { x: 0, y: 0, w: 20, h: 20 },\n            { x: 40, y: 0, w: 20, h: 20 },\n            { x: 80, y: 0, w: 20, h: 20 },\n            { x: 120, y: 0, w: 20, h: 20 }\n        ])\n    },\n    enemiesList: [],\n    init: function () {\n        let self = this;\n        game.on('update', function () {\n            self.update();\n        });\n    },\n    update: function () {\n        for (let i = this.enemiesList.length - 1; i >= 0; i--)\n            if (this.enemiesList[i].deleted === true) this.remove(i);\n    },\n    remove: function (index) {\n        mapEntities.remove(this.enemiesList[index].id);\n        this.enemiesList.splice(index, 1);\n    },\n    create: function (level, wave) {\n        let shift = Math.round(Math.random() * 40) - 10,\n            me = this,\n            entity = mapEntities.create(0, 0, 10, 'red');\n\n        entity.waypointIndex = 0;\n        entity.waypoint = {};\n\n        entity.shift = shift;\n        entity.velocity = {x: 0, y: 0};\n\n        if (!settings.enemyLevels[level]) level = game.settings.enemyLevels.length - 1;\n\n        let enemySettings = settings.enemyLevels[level];\n        entity.level = level;\n        entity.wave = wave;\n        entity.speed = enemySettings.speed;\n        entity.health = enemySettings.health;\n        entity.maxHealth = enemySettings.health;\n        entity.color = enemySettings.color;\n        entity.direction = 0;\n        entity.frame = 0;\n        entity.enemyType = 'irlicht';\n\n        entity.deleted = false;\n\n        entity.nextWaypoint = function () {\n            if (!this.waypoint.x) {\n                // Waypoint Objekt kopieren\n                this.waypoint = Object.assign({}, map.waypoints[this.waypointIndex]);\n                // Versatz aufaddieren\n                this.waypoint.x += this.shift;\n                this.waypoint.y += this.shift;\n                // Position übernehmen\n                this.x = this.waypoint.x;\n                this.y = this.waypoint.y;\n            }\n\n            // Den alten Wegpunkt für den späteren Vergleich merken.\n            let oldX = this.waypoint.x,\n                oldY = this.waypoint.y;\n\n            // Den nächsten Wegpunkt ansteuern\n            this.waypointIndex++;\n            if (!map.waypoints[this.waypointIndex]) return false;\n            this.waypoint = Object.assign({}, map.waypoints[this.waypointIndex]);\n\n            // Versatz aufaddieren\n            this.waypoint.x += this.shift;\n            this.waypoint.y += this.shift;\n\n            // Bewegungsernergie setzen\n            if (oldX === this.waypoint.x) {\n                this.velocity.x = 0;\n            } else {\n                this.velocity.x = (this.x < this.waypoint.x ? entity.speed : -entity.speed);\n            }\n\n            if (oldY === this.waypoint.y) {\n                this.velocity.y = 0;\n            } else {\n                this.velocity.y = (this.y < this.waypoint.y ? entity.speed : -entity.speed);\n            }\n\n            // Richtung setzen\n            if ( this.velocity.y < 0 && this.velocity.x === 0 ) {\n                this.direction = 0;\n            } else if ( this.velocity.x > 0 && this.velocity.y === 0 ) {\n                this.direction = 1;\n            } else if ( this.velocity.y > 0 && this.velocity.x === 0 ) {\n                this.direction = 2;\n            } else if ( this.velocity.x < 0 && this.velocity.y === 0 ) {\n                this.direction = 3;\n            }\n\n            return true;\n        };\n\n        entity.waypointReached = function () {\n            return (\n                (this.velocity.x > 0 && this.x >= this.waypoint.x)\n                || (this.velocity.x < 0 && this.x <= this.waypoint.x)\n                || (this.velocity.y > 0 && this.y >= this.waypoint.y)\n                || (this.velocity.y < 0 && this.y <= this.waypoint.y)\n            );\n        };\n\n        entity.update = function () {\n            if (this.deleted === true) return;\n            if (this.health <= 0) {\n                return this.die();\n            }\n\n            if (this.waypointReached()) {\n                if (!this.nextWaypoint())\n                    return this.done();\n            } else {\n                this.x += this.velocity.x;\n                this.y += this.velocity.y;\n            }\n\n            // Animation\n            this.frame += 0.2;\n            if ( this.frame >= enemies.images[this.enemyType].sprites[this.direction].frames.length ) {\n                this.frame = 0;\n            }\n\n        };\n\n        entity.draw = function () {\n            // Den Gegner zeichnen\n            helpers.drawAnimatedSprite(me.images.irlicht, this.direction, this.frame, Math.round(this.x), Math.round(this.y), 40, 40);\n\n            // Zeichne den Lebensbalken\n            let  healthPercent = this.health / this.maxHealth;\n\n            if ( healthPercent < 1 ) {\n                let healthBar = {\n                    x: this.x - this.r,\n                    y: this.y - this.r - 5,\n                    width: this.r * 2,\n                    height: 3\n                };\n                game.ctx.fillStyle = \"black\";\n                game.ctx.fillRect(healthBar.x, healthBar.y, healthBar.width, healthBar.height);\n\n                game.ctx.fillStyle = \"green\";\n                game.ctx.fillRect(healthBar.x, healthBar.y, healthBar.width * healthPercent, healthBar.height);\n            }\n\n\n        };\n\n        entity.die = function () {\n            this.health = 0;\n            this.deleted = true;\n\n            game.stat('coins', game.stat('coins') + enemies.calculateReward(entity.level), true);\n\n            // Wir überprüfen ob dies der letzte Gegner der Welle ist und vergeben Bonus Coins\n            let waveLastBonus = true;\n            for ( let id in enemies.enemiesList ) {\n                let enemy = enemies.enemiesList[id];\n                if ( enemy.wave === entity.wave && !enemy.deleted ) {\n                    waveLastBonus = false;\n                }\n            }\n\n            //if (waveLastBonus) game.stat('coins', game.stat('coins') + entity.wave, true);\n\n            return this;\n        };\n\n        entity.done = function () {\n            this.deleted = true;\n            let life = game.stat('life');\n            life -= 1;\n            if (life <= 0) {\n                game.resetGame();\n                alert('Du hast verloren!');\n            } else {\n                game.stat('life', life, true);\n            }\n\n            return this;\n        };\n\n        entity.damage = function (damage) {\n            this.health -= damage;\n            if (this.health <= 0 && !this.deleted) this.die();\n        };\n\n        // Zum nächsten Waypoint laufen\n        entity.nextWaypoint();\n        this.enemiesList.push(entity);\n\n        return entity;\n    },\n    calculateReward: function(level) {\n        let base = settings.enemyLevels[0],\n            enemy = settings.enemyLevels[level];\n\n        return Math.round((enemy.health / base.health) * (enemy.speed / base.speed)) + 4;\n    }\n};","import game from './game';\n\nexport default {\n    x: 0,\n    y: 0,\n    clicked: false,\n\n    // Initialisiert die Maus\n    init: function () {\n        let me = this;\n        // Update Event registrieren\n        game.on('update', function () {\n            me.update();\n        });\n\n        // Mausbewegung\n        game.canvas.addEventListener('mousemove', me.onMove);\n        game.canvas.addEventListener(\"click\", me.onClick);\n    },\n    update: function () {\n        game.mouse.clicked = false;\n    },\n    onMove: function (e) {\n        // Mausposition merken\n        game.mouse.x = e.offsetX;\n        game.mouse.y = e.offsetY;\n    },\n    onClick: function (e) {\n        game.mouse.clicked = true;\n    },\n    isMouseOver: function (x, y, radius) {\n        let me = this;\n\n        return Math.round(Math.sqrt(Math.pow(me.x - x, 2) + Math.pow(me.y - y, 2))) <= radius;\n    }\n};","import game from './game';\nimport map from './game.map';\nimport mouse from './game.mouse';\nimport settings from './game.settings';\nimport mapEntities from './game.mapEntities';\nimport enemies from './game.enemies';\nimport helpers from './helpers';\n\nexport default {\n    init: function () {\n        let me = this;\n        game.on('update', function () {\n            me.update();\n        });\n        game.on('afterDraw', function () {\n            me.draw();\n        });\n    },\n    update: function () {\n        let me = this,\n            gridPosition = me.gridPosition();\n\n        if (game.stat('mode') === 'dropTower' && map.isValidTowerPlace(gridPosition.x, gridPosition.y) && game.mouse.clicked) {\n            game.stat('mode', '');\n            this.create(gridPosition.x, gridPosition.y);\n        }\n    },\n    draw: function () {\n        let me = this;\n\n        if (game.stat('mode') === 'dropTower') {\n            let gridPosition = me.gridPosition();\n\n            // TODO We can buy some types of towers in future\n            let bullet = 'laser'\n\n            if (map.isValidTowerPlace(gridPosition.x, gridPosition.y)) {\n                // Wirkungsradius/Reichweite zeichnen\n                game.drawCircle(gridPosition.x, gridPosition.y, settings.towers[bullet].fireRange, 'rgba(0,0,255,0.2)', true);\n\n                //game.drawCircle(gridPosition.x, gridPosition.y, game.settings.tower.size, game.settings.tower.color, true);\n                helpers.drawSprite(settings.towers[bullet].images, 0, gridPosition.x, gridPosition.y - 20, 160, 160);\n            }\n            else {\n                game.drawCircle(gridPosition.x, gridPosition.y, settings.towers[bullet].size, 'gray', true);\n            }\n        }\n\n    },\n    create: function (x, y) {\n        // TODO We can buy some types of towers in future\n        let bullet = 'laser'\n\n        let me = this,\n            tower = settings.towers[bullet],\n            entity = mapEntities.create(x, y, tower.size, tower.color);\n\n        entity.type = 'tower';\n        entity.bullet = bullet;\n\n        entity.fireRange = tower.fireRange;\n        entity.damage = tower.damage;\n        entity.cooldownTime = tower.coolDownTime;\n        entity.barell = {x: x, y: y - (5 + entity.r)}\n        entity.audio = new Audio(tower.audio);\n        entity.audio.volume = 0.3;\n\n        // Turm Statistik Daten\n        entity.stats = {\n            shoots: 0,\n            dmg: 0,\n            kills: 0,\n        }\n\n        entity.cooldownCounter = 0;\n        entity.closestEnemy = false;\n\n        entity.upgrade = function() {\n            let coins = game.stat('coins'),\n                upgrade = settings.towers[entity.bullet].upgrades[entity.level];\n\n            if ( upgrade && coins >= upgrade.cost ) {\n\n                // Upgrade bezahlen\n                game.stat('coins', coins - upgrade.cost, true);\n\n                // Upgrade ausführen\n                entity.damage = upgrade.damage;\n                entity.fireRange = upgrade.fireRange;\n                entity.level ++;\n                entity.color = upgrade.color;\n\n                me.closeOptions();\n            }\n        }\n\n        entity.update = function () {\n            entity.cooldownCounter--;\n            let newEnemyDistance = game.distance(this.x, this.y, this.closestEnemy.x, this.closestEnemy.y);\n\n            if ( newEnemyDistance >= (this.fireRange + this.closestEnemy.r) || this.closestEnemy.health <= 0 ) {\n                this.closestEnemy = false;\n            }\n\n            if ( this.closestEnemy === false ) {\n\n                let closestDistance = Number.MAX_SAFE_INTEGER;\n                for (let i in enemies.enemiesList) {\n                    let enemy = enemies.enemiesList[i];\n                    let distance = game.distance(this.x, this.y, enemy.x, enemy.y);\n                    if (distance < closestDistance && distance <= (this.fireRange + enemy.r)) {\n                        closestDistance = distance;\n                        this.closestEnemy = enemy;\n                    }\n                }\n            }\n\n            if ( this.closestEnemy !== false ) {\n                this.closestEnemy.shoot = false;\n            }\n\n            if ( this.closestEnemy !== false && entity.cooldownCounter <= 0) {\n                this.shoot(this.closestEnemy);\n                this.closestEnemy.shoot = true;\n                entity.audio.play();\n            }\n\n            // Wenn man den Turm Hoverst soll sich der zIndex erhöhen\n            entity.zIndex = 10;\n            if (mouse.isMouseOver(this.x, this.y, this.r )) {\n                entity.zIndex = 100;\n            }\n\n            if ( game.stat('mode') !== 'dropTower' && mouse.clicked && mouse.isMouseOver(this.x, this.y, this.r ) ) {\n                me.openOptions(this);\n            }\n        };\n\n        entity.shoot = function (enemy) {\n            // DMG Range berechnen\n            let damage = Math.floor(Math.random() * (this.damage.to - this.damage.from + 1) + this.damage.from) ;\n\n            // Zählt die abgegebenen Shüsse\n            this.stats.shoots += 1;\n\n            // Zählt den gemachten Schaden\n            this.stats.dmg += damage;\n            enemy.damage(damage);\n\n            // Zählt die getöteten Gegner\n            if ( enemy.deleted ) {\n                this.stats.kills += 1;\n            }\n\n            this.cooldownCounter = this.cooldownTime;\n        };\n\n        entity.draw = function () {\n            // Wirkungsradius/Reichweite zeichnen\n            if (game.stat('mode') !== 'dropTower' && mouse.isMouseOver(this.x, this.y, this.r )) {\n                game.drawCircle(this.x, this.y, this.fireRange, 'rgba(0,0,255,0.2)', true);\n            }\n\n            // Den Turm zeichnen\n            helpers.drawSprite(settings.towers[entity.bullet].images, entity.level, entity.x, entity.y - 20, 160, 160);\n\n            if ( this.closestEnemy ) {\n                let eDistance = game.distance(this.x, this.y, this.closestEnemy.x, this.closestEnemy.y);\n\n                // Neue Turm Ausrichtung berechnen\n                let dRatio = (5 + this.r) / eDistance;\n                this.barell.x = this.x + dRatio * (this.closestEnemy.x - this.x);\n                this.barell.y = this.y + dRatio * (this.closestEnemy.y - this.y);\n            }\n\n\n            game.ctx.save();\n\n            // Schuss darstellen\n            if ( this.closestEnemy.shoot ) {\n                game.ctx.beginPath();\n                game.ctx.strokeStyle = entity.color;\n                game.ctx.lineWidth = 2;\n                game.ctx.moveTo(this.x, this.y - 50);\n                game.ctx.lineTo(this.closestEnemy.x, this.closestEnemy.y);\n                game.ctx.stroke();\n            }\n\n            // Turm Ausrichtung darstellen\n            // game.ctx.beginPath();\n            // game.ctx.strokeStyle = 'black';\n            // game.ctx.lineWidth = 5;\n            // game.ctx.moveTo(this.x, this.y);\n            // game.ctx.lineTo(this.barell.x, this.barell.y);\n            // game.ctx.stroke();\n\n            game.ctx.restore();\n\n        };\n        return entity;\n    },\n    gridPosition: function() {\n        let x = ((Math.floor(game.mouse.x / settings.mapGrid)) * settings.mapGrid) + (settings.mapGrid / 2),\n            y = ((Math.floor(game.mouse.y / settings.mapGrid)) * settings.mapGrid) + (settings.mapGrid / 2);\n\n        return {x: x, y: y};\n    },\n    drawTower: function(bullet, x, y, level) {\n        let image = this.images[bullet];\n        //console.log('before onload');\n        game.ctx.drawImage(image, 0, level * 160, image.width, image.width, x - 40, y - 60, 80, 80);\n    },\n    openOptions: function(tower) {\n        let optionsModal = document.querySelector('.modal-options');\n\n        game.output('#tower-position-x', tower.x);\n        game.output('#tower-position-y', tower.y);\n        game.output('#tower-level', tower.level +1);\n        game.output('#tower-fire-range', tower.fireRange);\n        game.output('#tower-cooldown-time', tower.cooldownTime);\n        game.output('#tower-damage-from', tower.damage.from);\n        game.output('#tower-damage-to', tower.damage.to);\n        game.output('#tower-stats-shoots', tower.stats.shoots);\n        game.output('#tower-stats-damage', tower.stats.dmg);\n        game.output('#tower-stats-kills', tower.stats.kills);\n\n        let upgrade = settings.towers[tower.bullet].upgrades[tower.level];\n        if ( upgrade ) {\n            optionsModal.querySelector('.tower-upgrade').classList.remove('is--hidden');\n\n            game.output('#tower-upgrade-level', tower.level + 2);\n            game.output('#tower-upgrade-cost', upgrade.cost);\n            game.output('#tower-upgrade-fire-range', upgrade.fireRange);\n            game.output('#tower-upgrade-damage-from', upgrade.damage.from);\n            game.output('#tower-upgrade-damage-to', upgrade.damage.to);\n            game.output('.modal-options .tower-upgrade-level', tower.level + 2);\n\n            optionsModal.querySelector('.tower-buy-upgrade').onclick = function() {\n                tower.upgrade();\n            }\n        } else {\n            optionsModal.querySelector('.tower-upgrade').classList.add('is--hidden');\n        }\n\n        optionsModal.classList.add('is--open');\n\n    }\n};","import map from './game.map';\nimport mapEntities from './game.mapEntities';\nimport enemies from './game.enemies';\nimport towers from './game.towers';\nimport mouse from './game.mouse';\nimport settings from './game.settings';\nimport helpers from \"./helpers\";\n\nexport default {\n    canvas: false,\t// Das Canvas Element. Hierüber erhalten wir die aktuelle Breite und Höhe des Canvas.\n    ctx: false,\t\t// Der Kontext über den wir auf dem Canvas zeichnen können.\n    drawList: [],\t// In dieser Liste werden alle zu zeichnenden Objekte gesammelt. Nach jedem \"draw()\"-Durchlauf ist die Liste leer und muss neu befüllt werden.\n    mouse: mouse,\n\n    // Hier werden das Spiel und alle Spielelemente initialisiert.\n    init: function () {\n        let me = this;\n\n        // Das Canvas-Element brauchen wir noch öfter\n        this.canvas = document.getElementById('canvas');\n\n        // Den 2D-Kontext merken wir uns in der game.ctx Variable.\n        this.ctx = this.canvas.getContext(\"2d\");\n\n        // Alle Erweiterungen initialisieren\n        map.init();\n        mapEntities.init();\n        enemies.init();\n        towers.init();\n        this.mouse.init();\n\n        // Einmalig schreiben wir in die Buttons die Kosten\n        this.output('#towerCosts', settings.towers.laser.costs);\n\n        // Alle Werte zurück setzen\n        me.resetGame();\n\n        // 30 mal in der Sekunde aktualisieren wir alle Objekte\n        setInterval(me.update.bind(this), 1000 / 30);\n\n        // Die \"draw\"-Schleife anstoßen\n        this.draw();\n    },\n    // Setzt alle Werte zurück. Diese Methode kann zur Initialisierung und zum Resetten verwendet werden.\n    resetGame: function () {\n        // Wir fangen wieder mit der ersten Welle an\n        this.waveCounter = 0;\n        // Alle bestehenden Entitäten entfernen\n        mapEntities.list = {};\n        // Anfangswerte setzen\n        this.stat('life', settings.playerLifes, true);\t// Leben des Spielers\n        this.stat('coins', 180, true);\t                // Genügend Coins für die ersten beiden Türme\n        this.stat('wave', 0, true);\t\t\t\t\t\t// Wir setzen initial die Welle auf 0. Mit Aufruf von \"nextWave()\" wird der Wert erhöht.\n    },\n    buyTower: function () {\n        // TODO We can buy some types of towers in future\n        let me = this,\n            bullet = 'laser'\n\n        if (me.stat('mode') !== 'dropTower') {\n            let coins = me.stat('coins');\n            if (coins >= settings.towers[bullet].costs) {\n                me.stat('mode', 'dropTower');\n                me.stat('coins', coins - settings.towers[bullet].costs, true);\n            }\n        }\n    },\n    update: function () {\n        this.trigger('update');\n    },\n    draw: function () {\n        let me = this;\n\n        // Animation Frame anfordern\n        window.requestAnimationFrame(me.draw.bind(this));\n        // Canvas leeren\n        me.ctx.clearRect(0, 0, me.canvas.width, me.canvas.height);\n\n        // Event triggern so das alle zu zeichnenden Objekte zur Liste \"drawList\"\n        // hinzugefügt werden können.\n        // Jedes Objekt, das dieser Liste hinzugefügt wird, benötigt die Eigenschaft \"y\", \"zIndex\"\n        // und die Methode \"draw()\" damit es sortiert wird und zum richtigen Zeitpunkt gezeichnet werden kann.\n        me.trigger('beforeDraw');\n\n        // Die Liste mit den zu zeichnenden Objekten vorsortieren\n        // damit die weiter oben angesetzten Objekte hinter den Vorderen liegen.\n        helpers._sortEntity.apply(me, ['drawList']);\n\n        // Für jedes Element der Liste rufen wir die Methode \"draw()\" auf.\n        // Diese Methode regelt die Darstellung des Objekts.\n        for (let i = me.drawList.length - 1; i >= 0; i--) {\n            me.drawList.splice(i, 1)[0].draw();\n        }\n\n        // Es gibt elemente die noch über den fest platzierten Elementen gezeichnet werden sollen\n        // Diese elemente werden im after Draw aufgerufen\n        me.trigger('afterDraw');\n    },\n    // Spielstati\n    stats: {},\n    stat: function (name, value, output) {\n        if (value === undefined) return this.stats[name] || false;\n        this.stats[name] = value;\n        if (output !== undefined) this.output(`#${name}`, value);\n        return this;\n    },\n    // Ausgabe\n    output: function (query, value) {\n        document.querySelector(query).innerHTML = value;\n    },\n    // Die Distanz zwischen zwei Punkten\n    distance: function (x1, y1, x2, y2) {\n        let a = x1 - x2,\n            b = y1 - y2;\n        return Math.sqrt(a * a + b * b);\n    },\n    intersectRect: function (r1, r2) {\n        return !(r2.left > r1.right ||\n            r2.right < r1.left ||\n            r2.top > r1.bottom ||\n            r2.bottom < r1.top);\n    },\n    drawCircle: function (x, y, r, color, fill = true) {\n        // Zunächst öffnen wir einen Pfad..\n        this.ctx.beginPath();\n        // .. zeichnen einen Bogen der mit 2*PI Umfang zu einem ganzen Kreis wird..\n        this.ctx.arc(x, y, r, 0, 2 * Math.PI);\n        if (fill === true) {\n            // ..setzen eine Füllfarbe..\n            this.ctx.fillStyle = color;\n            // .. und füllen diesen Bereich mit der vorher festgelegten Farbe\n            this.ctx.fill();\n        } else {\n            this.ctx.strokeStyle = color;\n            this.ctx.stroke();\n        }\n    },\n    // Waves\n    waveCounter: 0,\n    nextWave: function () {\n        // Es muss mindestens ein Turm existieren\n        if (Object.keys(mapEntities.list).length == 0) return this;\n        //if (this.stat('mode')!='nextWave') return this;\n\n        this.waveCounter++;\n        this.stat('wave', this.waveCounter, true);\n\n        let delay = 0,\n            levelInc = Math.floor(this.waveCounter / settings.enemyLevelIncAt),\n            maxTemplate = settings.waves.length - 1,\n            template = settings.waves[Math.min(levelInc, maxTemplate)].template;\n\n        for (let spawn of template) {\n            let ec = Math.round(spawn.count + (this.waveCounter * spawn.waveFactor)); // Die Anzahl der Gegner multiplitziert mit dem Wellen Faktor\n            setTimeout(function () {\n                for (let i = 0; i < ec; i++) {\n                    setTimeout(function () {\n                        enemies.create(spawn.level + levelInc, this.waveCounter);\n                    }, i * spawn.coolDown);\n                }\n            }, delay);\n            delay += (spawn.delay + (ec * spawn.coolDown)) * spawn.delayFactor;\n        }\n\n        return this;\n    },\n    // Events\n    eventsList: {},\n    on: function (event, fn) {\n        if (!this.eventsList[event]) this.eventsList[event] = [];\n        this.eventsList[event].push(fn);\n        return this;\n    },\n    trigger: function (event) {\n        if (!this.eventsList[event]) return this;\n        for (let i = 0; i < this.eventsList[event].length; i++) {\n            this.eventsList[event][i]();\n        }\n\n        return this;\n    }\n}","import game from './game';\n\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n    game.init();\n\n    document.addEventListener('click', function (event) {\n        if (!event.target.matches('#buy-tower')) return;\n        event.preventDefault();\n        game.buyTower();\n\n    }, false);\n\n    document.addEventListener('click', function (event) {\n        if (!event.target.matches('#next-wave')) return;\n        event.preventDefault();\n        game.nextWave();\n\n    }, false);\n\n    document.addEventListener('click', function (event) {\n        if (!event.target.matches('.modal-close')) return;\n        event.preventDefault();\n        document.querySelector('.modal-options').classList.remove('is--open');\n\n    }, false);\n});\n\n\n"]}